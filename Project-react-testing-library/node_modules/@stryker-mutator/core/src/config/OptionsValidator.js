"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.markUnknownOptions = exports.validateOptions = exports.defaultOptions = exports.OptionsValidator = void 0;
const Ajv = require("ajv");
const core_1 = require("@stryker-mutator/api/core");
const plugin_1 = require("@stryker-mutator/api/plugin");
const util_1 = require("@stryker-mutator/util");
const di_1 = require("../di");
const errors_1 = require("../errors");
const objectUtils_1 = require("../utils/objectUtils");
const validationErrors_1 = require("./validationErrors");
const ajv = new Ajv({ useDefaults: true, allErrors: true, jsonPointers: false, verbose: true, missingRefs: 'ignore', logger: false });
class OptionsValidator {
    constructor(schema, log) {
        this.log = log;
        this.validateFn = ajv.compile(schema);
    }
    validate(options) {
        this.schemaValidate(options);
        this.additionalValidation(options);
    }
    additionalValidation(options) {
        const additionalErrors = [];
        if (options.thresholds.high < options.thresholds.low) {
            additionalErrors.push('Config option "thresholds.high" should be higher than "thresholds.low".');
        }
        if (options.transpilers.length > 1 && options.coverageAnalysis !== 'off') {
            additionalErrors.push(util_1.normalizeWhitespaces(`Config option "coverageAnalysis" is invalid. Coverage analysis "${options.coverageAnalysis}" 
          is not supported for multiple transpilers (configured transpilers: ${options.transpilers.map((t) => `"${t}"`).join(', ')}).
          Change it to "off". Please report this to the Stryker team if you whish this feature to be implemented.`));
        }
        additionalErrors.forEach((error) => this.log.error(error));
        this.throwErrorIfNeeded(additionalErrors);
    }
    schemaValidate(options) {
        if (!this.validateFn(options)) {
            const errors = validationErrors_1.describeErrors(this.validateFn.errors);
            errors.forEach((error) => this.log.error(error));
            this.throwErrorIfNeeded(errors);
        }
    }
    throwErrorIfNeeded(errors) {
        if (errors.length > 0) {
            throw new errors_1.ConfigError(errors.length === 1 ? 'Please correct this configuration error and try again.' : 'Please correct these configuration errors and try again.');
        }
    }
}
exports.OptionsValidator = OptionsValidator;
OptionsValidator.inject = plugin_1.tokens(di_1.coreTokens.validationSchema, plugin_1.commonTokens.logger);
function defaultOptions() {
    const options = {};
    const validator = new OptionsValidator(core_1.strykerCoreSchema, util_1.noopLogger);
    validator.validate(options);
    return options;
}
exports.defaultOptions = defaultOptions;
validateOptions.inject = plugin_1.tokens(plugin_1.commonTokens.options, di_1.coreTokens.optionsValidator);
function validateOptions(options, optionsValidator) {
    optionsValidator.validate(options);
    return options;
}
exports.validateOptions = validateOptions;
markUnknownOptions.inject = plugin_1.tokens(plugin_1.commonTokens.options, di_1.coreTokens.validationSchema, plugin_1.commonTokens.logger);
function markUnknownOptions(options, schema, log) {
    const OPTIONS_ADDED_BY_STRYKER = ['set', 'configFile', '$schema'];
    if (objectUtils_1.isWarningEnabled('unknownOptions', options.warnings)) {
        const unknownPropertyNames = Object.keys(options)
            .filter((key) => !key.endsWith('_comment'))
            .filter((key) => !OPTIONS_ADDED_BY_STRYKER.includes(key))
            .filter((key) => !Object.keys(schema.properties).includes(key));
        unknownPropertyNames.forEach((unknownPropertyName) => {
            log.warn(`Unknown stryker config option "${unknownPropertyName}".`);
        });
        const p = `${util_1.propertyPath('warnings')}.${util_1.propertyPath('unknownOptions')}`;
        if (unknownPropertyNames.length) {
            log.warn(`
   Possible causes:
   * Is it a typo on your end?
   * Did you only write this property as a comment? If so, please postfix it with "_comment".
   * You might be missing a plugin that is supposed to use it. Stryker loaded plugins from: ${JSON.stringify(options.plugins)}
   * The plugin that is using it did not contribute explicit validation. 
   (disable "${p}" to ignore this warning)`);
        }
    }
    return options;
}
exports.markUnknownOptions = markUnknownOptions;
//# sourceMappingURL=OptionsValidator.js.map