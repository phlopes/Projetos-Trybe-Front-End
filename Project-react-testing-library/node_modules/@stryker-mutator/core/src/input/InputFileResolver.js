"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs_1 = require("fs");
const core_1 = require("@stryker-mutator/api/core");
const plugin_1 = require("@stryker-mutator/api/plugin");
const util_1 = require("@stryker-mutator/util");
const di_1 = require("../di");
const fileUtils_1 = require("../utils/fileUtils");
const OptionsValidator_1 = require("../config/OptionsValidator");
const InputFileCollection_1 = require("./InputFileCollection");
function toReportSourceFile(file) {
    return {
        content: file.textContent,
        path: file.name,
    };
}
const IGNORE_PATTERN_CHARACTER = '!';
class InputFileResolver {
    constructor(log, { mutate, files, tempDirName }, reporter) {
        this.log = log;
        this.reporter = reporter;
        this.tempDirName = tempDirName;
        this.mutatePatterns = mutate || [];
        if (files) {
            this.filePatterns = files;
        }
    }
    async resolve() {
        const [inputFileNames, mutateFiles] = await Promise.all([this.resolveInputFiles(), this.resolveMutateFiles()]);
        const files = await this.readFiles(inputFileNames);
        const inputFileCollection = new InputFileCollection_1.default(files, mutateFiles);
        this.reportAllSourceFilesRead(files);
        inputFileCollection.logFiles(this.log);
        return inputFileCollection;
    }
    resolveInputFiles() {
        if (this.filePatterns) {
            return this.expand(this.filePatterns);
        }
        else {
            return this.resolveFilesUsingGit();
        }
    }
    resolveMutateFiles() {
        return this.expand(this.mutatePatterns, !shallowEquals(this.mutatePatterns, OptionsValidator_1.defaultOptions().mutate));
        function shallowEquals(arr1, arr2) {
            if (arr1.length !== arr2.length) {
                return false;
            }
            else {
                for (let i = 0; i < arr1.length; i++) {
                    if (arr1[i] !== arr2[i]) {
                        return false;
                    }
                }
                return true;
            }
        }
    }
    /**
     * Takes a list of globbing patterns and expands them into files.
     * If a patterns starts with a `!`, it negates the pattern.
     * @param patterns The patterns to expand into files
     */
    async expand(patterns, logAboutUselessPatterns = true) {
        const fileSet = new Set();
        for (const pattern of patterns) {
            if (pattern.startsWith(IGNORE_PATTERN_CHARACTER)) {
                const files = await this.expandPattern(pattern.substr(1), logAboutUselessPatterns);
                files.forEach((fileName) => fileSet.delete(fileName));
            }
            else {
                const files = await this.expandPattern(pattern, logAboutUselessPatterns);
                files.forEach((fileName) => fileSet.add(fileName));
            }
        }
        return Array.from(fileSet);
    }
    async expandPattern(globbingExpression, logAboutUselessPatterns) {
        const fileNames = (await fileUtils_1.glob(globbingExpression)).map((relativeFile) => path.resolve(relativeFile));
        if (!fileNames.length && logAboutUselessPatterns) {
            this.log.warn(`Globbing expression "${globbingExpression}" did not result in any files.`);
        }
        return fileNames;
    }
    async resolveFilesUsingGit() {
        try {
            const { stdout } = await util_1.childProcessAsPromised.exec(`git ls-files --others --exclude-standard --cached --exclude /${this.tempDirName}/*`, {
                maxBuffer: 10 * 1000 * 1024,
            });
            const fileNames = stdout
                .toString()
                .split('\n')
                .map((line) => line.trim())
                .filter((line) => line) // remove empty lines
                .map((relativeFileName) => path.resolve(relativeFileName));
            return fileNames;
        }
        catch (error) {
            throw new util_1.StrykerError(util_1.normalizeWhitespaces(`Cannot determine input files. Either specify a \`files\`
        array in your stryker configuration, or make sure "${process.cwd()}"
        is located inside a git repository`), error);
        }
    }
    reportAllSourceFilesRead(allFiles) {
        this.reporter.onAllSourceFilesRead(allFiles.map(toReportSourceFile));
    }
    reportSourceFilesRead(textFile) {
        this.reporter.onSourceFileRead(toReportSourceFile(textFile));
    }
    async readFiles(fileNames) {
        const files = await Promise.all(fileNames.map((fileName) => this.readFile(fileName)));
        return files.filter(util_1.notEmpty);
    }
    readFile(fileName) {
        return fs_1.promises
            .readFile(fileName)
            .then((content) => new core_1.File(fileName, content))
            .then((file) => {
            this.reportSourceFilesRead(file);
            return file;
        })
            .catch((error) => {
            if ((util_1.isErrnoException(error) && error.code === 'ENOENT') || error.code === 'EISDIR') {
                return null; // file is deleted or a directory. This can be a valid result of the git command
            }
            else {
                // Rethrow
                throw error;
            }
        });
    }
}
exports.default = InputFileResolver;
InputFileResolver.inject = plugin_1.tokens(plugin_1.commonTokens.logger, plugin_1.commonTokens.options, di_1.coreTokens.reporter);
//# sourceMappingURL=InputFileResolver.js.map