"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MutationTestReportCalculator = void 0;
const path = require("path");
const plugin_1 = require("@stryker-mutator/api/plugin");
const report_1 = require("@stryker-mutator/api/report");
const util_1 = require("@stryker-mutator/util");
const mutation_testing_metrics_1 = require("mutation-testing-metrics");
const di_1 = require("../di");
const objectUtils_1 = require("../utils/objectUtils");
class MutationTestReportCalculator {
    constructor(reporter, options, inputFiles, log) {
        this.reporter = reporter;
        this.options = options;
        this.inputFiles = inputFiles;
        this.log = log;
    }
    report(results) {
        const report = this.mutationTestReport(results);
        this.reporter.onMutationTestReportReady(report);
        this.determineExitCode(report);
    }
    determineExitCode(report) {
        const { metrics } = mutation_testing_metrics_1.calculateMetrics(report.files);
        const breaking = this.options.thresholds.break;
        const formattedScore = metrics.mutationScore.toFixed(2);
        if (typeof breaking === 'number') {
            if (metrics.mutationScore < breaking) {
                this.log.error(`Final mutation score ${formattedScore} under breaking threshold ${breaking}, setting exit code to 1 (failure).`);
                this.log.info('(improve mutation score or set `thresholds.break = null` to prevent this error in the future)');
                objectUtils_1.setExitCode(1);
            }
            else {
                this.log.info(`Final mutation score of ${formattedScore} is greater than or equal to break threshold ${breaking}`);
            }
        }
        else {
            this.log.debug("No breaking threshold configured. Won't fail the build no matter how low your mutation score is. Set `thresholds.break` to change this behavior.");
        }
    }
    mutationTestReport(results) {
        return {
            files: this.toFileResults(results),
            schemaVersion: '1.0',
            thresholds: this.options.thresholds,
        };
    }
    toFileResults(results) {
        const resultDictionary = Object.create(null);
        results.forEach((mutantResult) => {
            const fileResult = resultDictionary[mutantResult.sourceFilePath];
            if (fileResult) {
                fileResult.mutants.push(this.toMutantResult(mutantResult));
            }
            else {
                const sourceFile = this.inputFiles.files.find((file) => file.name === mutantResult.sourceFilePath);
                if (sourceFile) {
                    resultDictionary[mutantResult.sourceFilePath] = {
                        language: this.determineLanguage(sourceFile.name),
                        mutants: [this.toMutantResult(mutantResult)],
                        source: sourceFile.textContent,
                    };
                }
                else {
                    this.log.warn(util_1.normalizeWhitespaces(`File "${mutantResult.sourceFilePath}" not found
          in input files, but did receive mutant result for it. This shouldn't happen`));
                }
            }
        });
        return resultDictionary;
    }
    determineLanguage(name) {
        const ext = path.extname(name).toLowerCase();
        switch (ext) {
            case '.ts':
            case '.tsx':
                return 'typescript';
            case '.html':
            case '.vue':
                return 'html';
            default:
                return 'javascript';
        }
    }
    toMutantResult(mutantResult) {
        return {
            id: mutantResult.id,
            location: this.toLocation(mutantResult.location),
            mutatorName: mutantResult.mutatorName,
            replacement: mutantResult.replacement,
            status: this.toStatus(mutantResult.status),
        };
    }
    toLocation(location) {
        return {
            end: this.toPosition(location.end),
            start: this.toPosition(location.start),
        };
    }
    toPosition(pos) {
        return {
            column: pos.column + 1,
            line: pos.line + 1,
        };
    }
    toStatus(status) {
        switch (status) {
            case report_1.MutantStatus.Killed:
                return "Killed" /* Killed */;
            case report_1.MutantStatus.NoCoverage:
                return "NoCoverage" /* NoCoverage */;
            case report_1.MutantStatus.RuntimeError:
                return "RuntimeError" /* RuntimeError */;
            case report_1.MutantStatus.Survived:
                return "Survived" /* Survived */;
            case report_1.MutantStatus.TimedOut:
                return "Timeout" /* Timeout */;
            case report_1.MutantStatus.TranspileError:
                return "CompileError" /* CompileError */;
            default:
                this.logUnsupportedMutantStatus(status);
                return "RuntimeError" /* RuntimeError */;
        }
    }
    logUnsupportedMutantStatus(status) {
        this.log.warn('Unable to convert "%s" to a MutantStatus', status);
    }
}
exports.MutationTestReportCalculator = MutationTestReportCalculator;
MutationTestReportCalculator.inject = plugin_1.tokens(di_1.coreTokens.reporter, plugin_1.commonTokens.options, di_1.coreTokens.inputFiles, plugin_1.commonTokens.logger);
//# sourceMappingURL=MutationTestReportCalculator.js.map